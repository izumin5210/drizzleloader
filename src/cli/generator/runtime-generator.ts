import type { AnalyzedTable } from "../analyzer/types.js";

/**
 * Describes which runtime helpers are needed for the generated code.
 */
export interface RuntimeUsage {
  /** DrizzleLoaderNotFound error class - always needed */
  needsError: boolean;
  /** buildLookupMap, lookupOrError - needed for single-column unique loaders */
  needsSimpleLookup: boolean;
  /** serializeCompositeKey, buildCompositeLookupMap, queryCompositeKey - needed for composite loaders */
  needsCompositeLookup: boolean;
}

/**
 * Analyzes tables to determine which runtime helpers are needed.
 */
export function analyzeRuntimeUsage(tables: AnalyzedTable[]): RuntimeUsage {
  let needsSimpleLookup = false;
  let needsCompositeLookup = false;

  for (const table of tables) {
    // Check primary key
    if (table.primaryKey) {
      if (table.primaryKey.columns.length === 1) {
        needsSimpleLookup = true;
      } else if (table.primaryKey.columns.length > 1) {
        needsCompositeLookup = true;
      }
    }

    // Check indexes
    for (const idx of table.indexes) {
      if (idx.columns.length === 1) {
        // Single-column index - only unique ones need simpleLookup
        if (idx.unique) {
          needsSimpleLookup = true;
        }
      } else if (idx.columns.length > 1) {
        needsCompositeLookup = true;
      }
    }
  }

  return {
    needsError: true,
    needsSimpleLookup,
    needsCompositeLookup,
  };
}

const FILE_HEADER = `// This file is auto-generated by drizzleloader. DO NOT EDIT.

`;

/**
 * Generates the runtime file content based on which helpers are needed.
 */
export function generateRuntimeFile(usage: RuntimeUsage): string {
  const lines: string[] = [];
  lines.push(FILE_HEADER);

  // drizzle-orm imports (only needed for composite lookup)
  if (usage.needsCompositeLookup) {
    lines.push('import type { Column, Table } from "drizzle-orm";');
    lines.push('import { and, eq, inArray, or } from "drizzle-orm";');
    lines.push(
      'import type { PgDatabase, PgQueryResultHKT } from "drizzle-orm/pg-core";',
    );
    lines.push("");
  }

  // DrizzleLoaderNotFound class
  lines.push(generateErrorClass());
  lines.push("");

  // Simple lookup helpers
  if (usage.needsSimpleLookup) {
    lines.push(generateSimpleLookupHelpers());
    lines.push("");
  }

  // Composite lookup helpers
  if (usage.needsCompositeLookup) {
    lines.push(generateCompositeLookupHelpers());
  }

  return lines.join("\n");
}

function generateErrorClass(): string {
  return `export class DrizzleLoaderNotFound extends Error {
  readonly table: string;
  readonly columns: Record<string, unknown>[];

  constructor(options: { table: string; columns: Record<string, unknown>[] }) {
    const columnStr = options.columns
      .map((col) =>
        Object.entries(col)
          .map(([k, v]) => \`\${k}=\${JSON.stringify(v)}\`)
          .join(", "),
      )
      .join("; ");
    super(\`Record not found in \${options.table} for \${columnStr}\`);
    this.name = "DrizzleLoaderNotFound";
    this.table = options.table;
    this.columns = options.columns;
  }
}`;
}

function generateSimpleLookupHelpers(): string {
  return `export function buildLookupMap<K, V>(
  rows: V[],
  keyFn: (row: V) => K,
): Map<K, V> {
  return new Map(rows.map((row) => [keyFn(row), row]));
}

export function lookupOrError<K, V>(
  map: Map<K, V>,
  key: K,
  table: string,
  column: string,
): V | DrizzleLoaderNotFound {
  return (
    map.get(key) ??
    new DrizzleLoaderNotFound({ table, columns: [{ [column]: key }] })
  );
}`;
}

function generateCompositeLookupHelpers(): string {
  return `// biome-ignore lint/suspicious/noExplicitAny: drizzle-orm's schema type is too complex to express generically
type AnyDb = PgDatabase<PgQueryResultHKT, any>;

type QueryBuilder = ReturnType<ReturnType<AnyDb["select"]>["from"]>;

export function serializeCompositeKey<T extends Record<string, unknown>>(
  key: T,
  keyColumns: readonly (keyof T)[],
): string {
  return keyColumns.map((col) => String(key[col])).join("\\0");
}

export function buildCompositeLookupMap<TRow extends Record<string, unknown>>(
  rows: TRow[],
  keyColumns: readonly string[],
): Map<string, TRow[]> {
  const map = new Map<string, TRow[]>();
  for (const row of rows) {
    const keyStr = keyColumns.map((col) => String(row[col])).join("\\0");
    const existing = map.get(keyStr) ?? [];
    existing.push(row);
    map.set(keyStr, existing);
  }
  return map;
}

/**
 * Builds a query for composite keys without executing it.
 * Useful for testing with toSQL().
 */
export function buildCompositeQuery(
  db: AnyDb,
  table: Table,
  columns: Column[],
  keyProps: readonly string[],
  keys: readonly Record<string, unknown>[],
): QueryBuilder | null {
  if (keys.length === 0) return null;

  // Optimization: detect fixed columns (same value from start)
  const fixedCols: { col: Column; keyProp: string; value: unknown }[] = [];
  const variableCols: { col: Column; keyProp: string }[] = [];

  for (let i = 0; i < columns.length; i++) {
    const col = columns[i]!;
    const keyProp = keyProps[i]!;
    const firstValue = keys[0]![keyProp];
    const allSame = keys.every((k) => k[keyProp] === firstValue);

    if (allSame && variableCols.length === 0) {
      fixedCols.push({ col, keyProp, value: firstValue });
    } else {
      variableCols.push({ col, keyProp });
    }
  }

  // biome-ignore lint/suspicious/noExplicitAny: drizzle-orm's query builder types are complex and don't support generic chaining
  let query: any = db.select().from(table);

  // Collect all conditions
  const fixedConditions = fixedCols.map(({ col, value }) => eq(col, value));

  // Variable columns
  if (variableCols.length === 0) {
    // All fixed - apply fixed conditions only
    if (fixedConditions.length > 0) {
      query = query.where(and(...fixedConditions));
    }
  } else if (variableCols.length === 1) {
    // Single variable -> IN
    const { col, keyProp } = variableCols[0]!;
    const values = [...new Set(keys.map((k) => k[keyProp]))];
    const variableCondition = inArray(col, values as unknown[]);
    query = query.where(and(...fixedConditions, variableCondition));
  } else {
    // Multiple variable -> OR conditions
    const orConditions = keys.map((key) => {
      const colConditions = variableCols.map(({ col, keyProp }) =>
        eq(col, key[keyProp]),
      );
      return and(...colConditions);
    });
    query = query.where(and(...fixedConditions, or(...orConditions)));
  }

  return query as QueryBuilder;
}

export async function queryCompositeKey<TRow>(
  db: AnyDb,
  table: Table,
  columns: Column[],
  keyProps: readonly string[],
  keys: readonly Record<string, unknown>[],
): Promise<TRow[]> {
  const query = buildCompositeQuery(db, table, columns, keyProps, keys);
  if (query === null) return [];
  return query as Promise<TRow[]>;
}`;
}
